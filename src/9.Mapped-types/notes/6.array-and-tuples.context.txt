Mapped Types with Arrays and Tuples

Mapped types arenâ€™t limited to plain objects â€”
they also work beautifully with arrays and tuples.

This means you can transform each element of an array or tuple into a new structure using simple generic patterns.

ğŸ”¹ Wrapping Elements of Arrays or Tuples

Letâ€™s create a mapped type that wraps each element inside an object with a value property.

ğŸ§© Example
type WrapElements<T extends readonly unknown[]> = {
  [K in keyof T]: { value: T[K] };
};


Hereâ€™s how it works:

We loop through all indices of the array/tuple using [K in keyof T].

For each element, we build an object with { value: ... }.

The type of value corresponds to the elementâ€™s original type.

ğŸ§ª Example 1 â€” Array of Strings
type MyStrings = string[];

type WrappedStrings = WrapElements<MyStrings>;


âœ… Result:

type WrappedStrings = {
  [index: number]: { value: string };
};


So now, instead of each element being a plain string,
each element is an object: { value: string }.

ğŸ§ª Example 2 â€” Tuple Transformation
type MyTuple = [number, boolean, 23];
type WrappedTuple = WrapElements<MyTuple>;


âœ… Result:

type WrappedTuple = [
  { value: number },
  { value: boolean },
  { value: 23 }
];


Each tuple element is transformed into an object with the same corresponding type inside the value property.

ğŸ”¹ Conditional Mapping on Tuple Elements

You can even use conditional types inside mapped types to perform advanced transformations â€”
for example, extracting data patterns from tuple values.

ğŸ§© Example â€” Extracting Keys from Tuples

Suppose you have a tuple of strings like this:

type KeyTuple = ["key-123", "key-456", "blah-blah"];


We want to extract just the numbers from strings that start with "key-".

âš™ï¸ Implementation
type ExtractKeys<T extends readonly string[]> = {
  [I in keyof T]: T[I] extends `key-${infer K}` ? K : T[I];
};


âœ… Result:

type RealKeysTuple = ExtractKeys<KeyTuple>;


Hovering over RealKeysTuple shows:

type RealKeysTuple = ["123", "456", "blah-blah"];

ğŸ§  How It Works

T[I] â†’ Accesses the value at index I of the tuple.

extends \key-${infer K}`` â†’ Checks if the element matches a pattern.

infer K â†’ Captures the part after "key-" (e.g., "123", "456").

? K : T[I] â†’ If it matches, return the captured key; otherwise, keep the original value.

âœ… Summary
Concept	Description	Example
Mapped over arrays/tuples	Loops over array indices	[K in keyof T]
Conditional check	Filters or transforms based on pattern	T[K] extends \key-${infer K}``
Infer keyword	Extracts part of a matched string	infer K
Works on tuples too	Maintains tuple structure in output	[number, string] â†’ [{value:number}, {value:string}]
ğŸš€ Takeaway

Mapped types arenâ€™t limited to objects â€”
you can use them with arrays and tuples to:

Wrap elements in custom shapes,

Apply transformations,

Extract information using template literals and conditional types.

This unlocks extremely powerful type-level data transformations â€”
all evaluated at compile time! ğŸ’¡