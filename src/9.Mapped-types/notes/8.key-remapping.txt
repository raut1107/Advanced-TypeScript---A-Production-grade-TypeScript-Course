Remapping Keys in Mapped Types

So far, when using mapped types, weâ€™ve preserved the original keys of the object.
But what if we want to rename or remap keys dynamically while transforming values?

TypeScript provides a powerful feature for that â€” using the as clause inside mapped types.

ðŸ”¹ The Goal

Suppose we have an object type:

type Resources = {
  product: string;
  customer: string;
  inventory: number;
};


We want to create a new type where:

Each value becomes a function returning the original type.

string â†’ () => string

number â†’ () => number

Each key is renamed:

Add a get prefix.

Capitalize the original key.
(product â†’ GetProduct, customer â†’ GetCustomer, etc.)

âœ… Expected result:

type RemappedResources = {
  GetProduct: () => string;
  GetCustomer: () => string;
  GetInventory: () => number;
};

ðŸ”¹ Step 1 â€” Create a Basic Mapped Type

Letâ€™s start with a generic mapped type that preserves the same keys and values.

type RemapKeys<T> = {
  [K in keyof T]: T[K];
};


This just copies the structure of the object â€” nothing new yet.

ðŸ”¹ Step 2 â€” Transform Value Types

Now, letâ€™s convert every propertyâ€™s value into a function returning that type.

type RemapKeys<T> = {
  [K in keyof T]: () => T[K];
};


âœ… Example:

type Test1 = RemapKeys<Resources>;


Result:

type Test1 = {
  product: () => string;
  customer: () => string;
  inventory: () => number;
};


Perfect â€” values transformed.
Now weâ€™ll move to the key transformation.

ðŸ”¹ Step 3 â€” Build the New Key Names

We want new keys like GetProduct, GetCustomer, etc.
Letâ€™s experiment with template literal types and Capitalize.

type NewKeys = `Get${Capitalize<keyof Resources & string>}`;


âœ… Result:

"GetProduct" | "GetCustomer" | "GetInventory"


Exactly what we want!

ðŸ”¹ Step 4 â€” Apply Key Remapping with as

TypeScript allows you to remap keys using the as keyword in a mapped type.

Hereâ€™s the syntax:

type RemapKeys<T> = {
  [K in keyof T as `Get${Capitalize<K & string>}`]: () => T[K];
};


Breakdown:

K in keyof T â†’ iterate over each key.

as â†’ remap the key to a new name.

`Get${Capitalize<K & string>}` â†’ use a template literal to construct the new key.

& string ensures K is treated as a string (required for Capitalize).

ðŸ”¹ Step 5 â€” Test It
type Test2 = RemapKeys<Resources>;


âœ… Result:

type Test2 = {
  GetProduct: () => string;
  GetCustomer: () => string;
  GetInventory: () => number;
};


It works beautifully!

ðŸ§  How It Works
Concept	Explanation
Mapped Types	Loop through properties of a type.
as Clause	Used to remap keys while preserving their relationship to original keys.
Template Literals	Build new string keys dynamically (Get${...}).
Capitalize<> Utility	Converts the first letter of a string literal type to uppercase.
& string	Ensures keys are strings for template literal manipulation.
ðŸ§© Full Example Code
type Resources = {
  product: string;
  customer: string;
  inventory: number;
};

type RemapKeys<T> = {
  [K in keyof T as `Get${Capitalize<K & string>}`]: () => T[K];
};

type Getters = RemapKeys<Resources>;


âœ… Output type:

type Getters = {
  GetProduct: () => string;
  GetCustomer: () => string;
  GetInventory: () => number;
};

ðŸ§° Bonus Tip â€” Why Use as

Without the as clause, the mapped typeâ€™s keys must match the original ones.
With as, we can transform, prefix, suffix, or fully replace keys dynamically.

Example:

[K in keyof T as `Prefix_${K}`]
[K in keyof T as Uppercase<K & string>]
[K in keyof T as Exclude<K, "id">]

ðŸš€ Summary
Feature	Purpose	Example
as in mapped types	Remap or rename keys	[K in keyof T as NewKey<K>]
Template literals	Build dynamic key names	`Get${Capitalize<K>}`
Capitalize utility	Uppercase first letter	Capitalize<"product"> â†’ "Product"
Value transformation	Wrap types in functions	() => T[K]

âœ… Final Takeaway:

Mapped types with the as clause let you transform both keys and values at the type level â€” enabling dynamic, readable, and highly reusable type logic.
