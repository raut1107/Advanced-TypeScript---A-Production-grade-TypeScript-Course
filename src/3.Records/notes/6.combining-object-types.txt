ğŸŒŸ Breaking Complex Types into Reusable Pieces (Intersection Types)

Sometimes, itâ€™s helpful to break up a complex type into smaller, reusable parts.
In TypeScript, you can do this by defining separate object types and then merging them using the intersection operator (&).

This approach lets you build larger, flexible types that combine all properties from multiple smaller ones.

ğŸ§© Example: Splitting and Combining Types

Letâ€™s say you want to create a type for a person by defining separate pieces of information:

type Identity = {
  id: number;
};

type PersonalInfo = {
  firstName: string;
  lastName: string;
};

type Permission = {
  canAccess: boolean;
};


Each of these types describes one part of a personâ€™s details.

ğŸ”— Combining Types Using Intersection

Now, you can combine them to create a complete type:

type UserProfile = Identity & PersonalInfo & Permission;


âœ… The UserProfile type now includes all properties:

id

firstName

lastName

canAccess

Any object of this type must provide all these properties:

const user: UserProfile = {
  id: 1,
  firstName: "Sanchita",
  lastName: "Raut",
  canAccess: true
};

âš™ï¸ Creating Partial or Specialized Types

You donâ€™t have to combine all the smaller types every time.
You can merge only some of them to form a lighter version:

type BasicProfile = Identity & PersonalInfo;


Now, a BasicProfile object only needs id, firstName, and lastName.

const basicUser: BasicProfile = {
  id: 2,
  firstName: "Arjun",
  lastName: "Patel"
};

ğŸ§  Why This Is Useful

Using intersections (&) makes your type system:

Modular â€“ you can reuse small pieces across different parts of your code.

Consistent â€“ shared pieces (like Identity) always mean the same thing.

Maintainable â€“ easy to extend or refactor large, complex types.

ğŸ§© Summary
Concept	Syntax	Description
Intersection	TypeA & TypeB	Combines all properties from both types
Modular reuse	Define small object types	Build bigger types by merging smaller ones
Example	type User = Identity & Info	Includes all fields from both

ğŸ¯ In Short

Use intersection types (&) to merge multiple smaller types.

Great for creating modular, maintainable type definitions.

You can mix and match to form different variations of complex types.