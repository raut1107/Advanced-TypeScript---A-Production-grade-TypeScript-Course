ğŸŒŸ Modular Object Types and Reuse with Intersections & Interfaces

Weâ€™ve already learned how to break down complex object types into smaller, modular, and reusable pieces using intersections (&).
Now, weâ€™ll see how to take that same concept even further â€” and how interfaces can achieve the same goal in a slightly different way.

ğŸ§© Example: Making Object Types Modular

Suppose we have two object types â€” an Article and a Feedback.
Both share some identical properties: id and postedAt.

type Article = {
  id: string;
  postedAt: Date;
  headline: string;
  content: string;
};

type Feedback = {
  id: string;
  postedAt: Date;
  comment: string;
};


At first glance, you can notice duplication here â€” both contain the same two properties (id and postedAt).

ğŸ’¡ Time for a â€œlight bulbâ€ moment:
Letâ€™s extract these shared properties into a base type so both objects can reuse them.

ğŸ”§ Step 1: Create a Base Type

Weâ€™ll define a Base type that includes only the shared fields:

type Base = {
  id: string;
  postedAt: Date;
};

ğŸ”— Step 2: Combine Using Intersection

Now, we can simplify both objects by using the intersection operator (&):

type Article = Base & {
  headline: string;
  content: string;
};

type Feedback = Base & {
  comment: string;
};


âœ… Now both Article and Feedback automatically include id and postedAt, without repeating them.

ğŸ§  Step 3: Doing the Same Thing with Interfaces

In TypeScript, interfaces can do exactly the same thing â€” but with a different syntax.

Hereâ€™s the same example rewritten with interfaces:

interface Base {
  id: string;
  postedAt: Date;
}

interface Article extends Base {
  headline: string;
  content: string;
}

interface Feedback extends Base {
  comment: string;
}


ğŸš€ Notice the differences:

Interfaces donâ€™t use the = sign.

To combine or inherit properties, we use the extends keyword instead of the & operator.

ğŸ§© Step 4: Extending Multiple Interfaces

One great feature of interfaces is that they can extend multiple interfaces at once â€”
perfect for when you want to compose types from smaller pieces.

For example:

interface HasId {
  id: string;
}

interface HasCreatedAt {
  createdAt: Date;
}

interface Article extends HasId, HasCreatedAt {
  headline: string;
  content: string;
}


âœ… Here, Article inherits properties from both HasId and HasCreatedAt.

ğŸ§  Why Use Interfaces?
Feature	type + &	interface + extends
Syntax	Uses & to combine	Uses extends
Multiple inheritance	âœ… Yes	âœ… Yes
Declaration merging	âŒ No	âœ… Yes
Common usage	Utility types, unions	Class and API design
ğŸ¯ Summary

Extract shared fields into a base type or interface.

Combine them using:

& (for types), or

extends (for interfaces).

Interfaces support multiple extensions â€” great for modular design.

Both methods help you avoid duplication and keep your code organized.

ğŸ§© Quick Recap Code
interface Base {
  id: string;
  postedAt: Date;
}

interface Article extends Base {
  headline: string;
  content: string;
}

interface Feedback extends Base {
  comment: string;
}


Both Article and Feedback now share the same base structure without any repetition ğŸ‰