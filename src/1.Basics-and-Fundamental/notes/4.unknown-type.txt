ğŸŒŸ The unknown Type in TypeScript

Letâ€™s talk about the unknown type and where it fits into the TypeScript type hierarchy â€” the mental model weâ€™ve been building.

ğŸ”¹ Where unknown Sits in the Type Hierarchy

In TypeScript, unknown sits at the very top of the type hierarchy.

This means:
âœ… Every type is assignable to unknown
âŒ But unknown is not assignable to other types (without narrowing).

So, unknown is the widest possible type in TypeScript.

ğŸ”¸ When to Use unknown

We usually use unknown when we donâ€™t know the exact type of a value yet.
Common examples include:

Form inputs coming from a frontend

JSON data received from an external API

Any variable whose structure is uncertain at compile time

Example:

let userInput: unknown;

userInput = "Hello";   // âœ… OK
userInput = 42;        // âœ… OK
userInput = { name: "Alice" }; // âœ… OK


But since itâ€™s unknown, you cannot use it directly without checking its type first:

if (typeof userInput === "string") {
  console.log(userInput.toUpperCase());  // âœ… Safe
}


ğŸ”¹ unknown in Intersections ( & )

What happens if we intersect unknown with another type?

Example:

type Result = unknown & string;


Hereâ€™s how it works:

Intersection (&) keeps only the common parts between both types.

Since unknown is the widest type, every other type (like string) is a subtype of it.

âœ… Therefore, the intersection resolves to the narrower type, i.e. string.

Example summary:

unknown & string   â†’ string
unknown & "hi"     â†’ "hi"
unknown & number   â†’ number


ğŸ§  Rule:
ğŸ‘‰ Intersection types always resolve to the narrowest type among the operands.

ğŸ”¸ unknown in Unions ( | )

Now, what happens when we use unknown in a union?

Example:

type Result = unknown | string;


A union ( | ) keeps all possible options.

It resolves to the widest branch among them.

Since unknown is the widest type, it dominates the union.

âœ… So:

unknown | string   â†’ unknown
unknown | number   â†’ unknown


ğŸ§  Rule:
ğŸ‘‰ Union types always resolve to the widest type among the operands.

ğŸ”¹ Literal and Primitive Type Example

Example:

type Example = "hi" | string;


Here:

"hi" is a string literal type

string is the wider primitive type

âœ… The resulting type is string â€” because string sits higher in the hierarchy.

ğŸ”¸ Unions with Types at the Same Level

If multiple types sit at the same height in the type hierarchy,
then their union simply keeps all of them.

Example:

type Example = string | number | boolean;


Here:

All three (string, number, boolean) are primitive types

They share the same â€œheightâ€ in the hierarchy
âœ… The resulting type remains a union of them

Result: string | number | boolean


ğŸ“Š Quick Summary of Type Behavior

Operation	Chooses	Example	Result
Intersection (&)	Narrowest type	unknown & string	string
Union (`	`)	Widest type	unknown | string

ğŸ§  Type Hierarchy Reminder (Top â†’ Bottom)

unknown
 â”œâ”€â”€ any
 â”‚   â”œâ”€â”€ string | number | boolean | object | ...
 â”‚   â”‚     â”œâ”€â”€ "hi", "bye", 42, etc. (literals)
 â”‚   â”‚
 â”‚   â””â”€â”€ never (bottom)


Top (unknown): widest type â€” everything is assignable to it

Bottom (never): narrowest type â€” assignable to nothing

ğŸ¯ Why This Matters

Every type error in TypeScript is actually about wrong assignability.

If you understand where a type sits in the hierarchy,
you can easily figure out why one type isnâ€™t assignable to another.

âœ… Intersection â†’ Narrowest
âœ… Union â†’ Widest
âœ… unknown â†’ Top of hierarchy
âœ… never â†’ Bottom of hierarchy

ğŸ’¡ In Short

unknown means â€œI donâ€™t know what this is yet.â€

Everything can be assigned to it.

But it canâ€™t be assigned from it without narrowing.

In intersections, it resolves to the narrower type.

In unions, it resolves to the wider type.

Understanding where it fits in the type hierarchy helps debug type errors easily.