üåü Union Types and Intersection Types in TypeScript

In TypeScript, there are two powerful concepts that let you build advanced and flexible type definitions:
Union types ( | ) and Intersection types ( & ).

These aren‚Äôt just simple operators ‚Äî they let you combine and compose types to describe complex sets of possibilities.

üîπ Union Types ( | )

A union type represents a value that can be one of several types.
Think of it as a collection of possible options.

Example:

type NotificationMethod = "email" | "sms" | "push";


Here:

The NotificationMethod type allows only one of these three exact string values:
"email", "sms", or "push"

‚úÖ Valid assignments:

let method: NotificationMethod;
method = "email";  // ‚úÖ OK
method = "sms";    // ‚úÖ OK
method = "push";   // ‚úÖ OK


‚ùå Invalid:

method = "call";   // ‚ùå Error: not assignable to type NotificationMethod


üß† Concept:
A union type combines multiple types and allows a value to be any one of them.

Later, we‚Äôll see how conditional types can iterate over union branches ‚Äî making TypeScript extremely powerful and expressive.

üî∏ Intersection Types ( & )

An intersection type combines multiple types into one.
A value of an intersection type must satisfy all the individual types it combines.

Example:

type Person = {
  name: string;
};

type RecordLabel = {
  recordId: number;
};

type Employee = Person & RecordLabel;


Here:

Employee is an intersection of Person and RecordLabel

That means it must have both:

a name (from Person)

a recordId (from RecordLabel)

‚úÖ Example usage:

const emp: Employee = {
  name: "John",
  recordId: 123,
};  // ‚úÖ Works fine


‚ùå If you miss one:

const wrongEmp: Employee = {
  name: "John",
};  // ‚ùå Error: recordId is missing


üß© Intersection = combine all properties of all types into one bigger type.

‚öôÔ∏è Union vs Intersection Quick Summary

Concept	Symbol	Meaning	Example
Union	`	`	Value can be one of multiple types
Intersection	&	Value must include all combined types	Person & RecordLabel

üîç Assignability in Union Types

Let‚Äôs say we have:

type StringOrNumber = string | number;


‚úÖ You can assign:

a string to it

or a number to it

because both are part of the union.

Example:

let val: StringOrNumber;
val = "hello"; // ‚úÖ
val = 42;      // ‚úÖ


‚ùå But you cannot assign a union type back to a single branch:

let text: string;
text = val; // ‚ùå Error if val could also be a number


üß† Assignability only flows from narrow ‚Üí wide, not the other way around.

üìä Type Hierarchy (Assignability Direction)

Think of type relationships like a pyramid:

        string | number
         /          \
    string          number


Assignments go upward (from bottom to top)

You can assign a narrower type (like string) to a wider one (like string | number)

But not the other way around

‚úÖ Example:

let a: "one" = "one";
let b: 1 | 2 | 3 | 4;

b = a;  // ‚úÖ OK (literal -> union)
a = b;  // ‚ùå Error (union -> literal)


üß† In Short

Union types ( | ) ‚Üí allow one of several possible types

Intersection types ( & ) ‚Üí require satisfying all combined types

Assignability flows from specific ‚Üí general, never the reverse

These tools let you describe rich, type-safe data shapes in TypeScript

üéØ Summary Example

type NotificationMethod = "email" | "sms" | "push";  // Union
type Person = { name: string };
type RecordLabel = { recordId: number };
type Employee = Person & RecordLabel;                // Intersection

const sendNotification = (method: NotificationMethod) => {
  console.log(`Sending via ${method}`);
};

const emp: Employee = { name: "Alice", recordId: 1 };
sendNotification("email"); // ‚úÖ Works
sendNotification("call");  // ‚ùå Error: not allowed
