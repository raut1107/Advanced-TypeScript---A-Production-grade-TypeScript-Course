â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“˜ LESSON: Filtering Union Types with Extract and Exclude
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Filtering union types is very common in TypeScript.  
Thatâ€™s why TypeScript provides two very useful **built-in utility types**:
- `Extract<T, U>`  
- `Exclude<T, U>`

These types allow us to **filter members** of a union **based on certain criteria** â€” without writing conditional types manually.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Example 1: Removing Non-String Members
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Suppose we have a union type that mixes strings and numbers:

```ts
type Stages = "draft" | "published" | "archived" | 404;
We only want to keep the string members and exclude the number.

Using Extract, we can do this easily:

ts
Copy code
type FilteredStages = Extract<Stages, string>;
âœ… Result:

ts
Copy code
// "draft" | "published" | "archived"
If you hover over FilteredStages, youâ€™ll see that 404 (the number) has been removed.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Example 2: Extracting Members That Match a Pattern
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Letâ€™s say we have an Operations union representing possible CRUD operation names:

ts
Copy code
type Operations = "getUser" | "getProduct" | "postOrder" | "postReview";
We want to keep only operations starting with â€œgetâ€.

We can use Extract again â€” this time with template literal types to form a pattern:

ts
Copy code
type FilteredOperations = Extract<Operations, `get${string}`>;
âœ… Result:

ts
Copy code
// "getUser" | "getProduct"
Here, `get${string}` means â€œany string that starts with â€˜getâ€™.â€
So only the matching union members are kept.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Example 3: Using Exclude
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Exclude works in the opposite way of Extract.
It removes members that match a certain condition.

Letâ€™s revisit our stages example:

ts
Copy code
type FilteredStages2 = Exclude<Stages, number>;
âœ… Result:

ts
Copy code
// "draft" | "published" | "archived"
This gives the same result as before â€” but internally works in reverse.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ How They Work Internally
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

If you hover over the built-in definitions:

ts
Copy code
type Extract<T, U> = T extends U ? T : never;
type Exclude<T, U> = T extends U ? never : T;
So:

Extract keeps members that extend U.

Exclude keeps members that do not extend U.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Example 4: Excluding Members by Pattern
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

We can also combine Exclude with template literals:

ts
Copy code
type FilteredOperations2 = Exclude<Operations, `post${string}`>;
âœ… Result:

ts
Copy code
// "getUser" | "getProduct"
Here, weâ€™re removing all operations that start with "post".

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Extract<T, U> â†’ keeps only members of T that extend U.

Exclude<T, U> â†’ removes members of T that extend U.

You can combine both with template literal types for pattern-based filtering.

These helpers make union filtering concise, clean, and readable.

yaml
Copy code
