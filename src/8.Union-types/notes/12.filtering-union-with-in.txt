â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“˜ LESSON: Narrowing Union Types Using the "in" Operator
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Letâ€™s see another example of **filtering** â€” specifically, **narrowing down a union type**.

Suppose we have a `BookingResponse` type that represents the outcome of a booking request.

Itâ€™s a union of two possible objects:
- One that contains a **confirmation** property, and  
- Another that contains an **error** property.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Example: BookingResponse Union
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```ts
type BookingResponse =
  | { confirmation: { asset: string } }
  | { error: string };
Now imagine a function that receives a BookingResponse and performs logic depending on which branch it is.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Without Narrowing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ts
Copy code
function handleBooking(response: BookingResponse) {
  console.log(response.confirmation.asset);
  console.error(response.error);
}
If you try this, TypeScript will complain:

âŒ Property 'confirmation' does not exist on type '{ error: string; }'
âŒ Property 'error' does not exist on type '{ confirmation: { asset: string; }; }'

Thatâ€™s because response could be either of the two branches,
and TypeScript prevents unsafe access to properties that donâ€™t exist on all members.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Naive Fix (Not Recommended)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

You might think about adding optional properties like this:

ts
Copy code
type BookingResponse =
  | { confirmation?: { asset: string }; error?: string };
But that defeats the purpose of a discriminated union,
and doesnâ€™t give you proper type safety.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Correct Solution: Using the "in" Operator
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Instead, we can use the in keyword to safely check for the existence of a property:

ts
Copy code
function handleBooking(response: BookingResponse) {
  if ("confirmation" in response) {
    // âœ… Narrowed type: { confirmation: { asset: string } }
    console.log("Booking confirmed for:", response.confirmation.asset);
  } else {
    // âœ… Narrowed type: { error: string }
    console.error("Booking failed:", response.error);
  }
}
When you use "confirmation" in response, TypeScript narrows the union:

Inside the if block, response is inferred as { confirmation: { asset: string } }.

Inside the else block, response is inferred as { error: string }.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The in operator is a simple, powerful way to narrow down union types when working with objects.

It checks if a property exists in an object at runtime and helps TypeScript infer the correct type branch.

Itâ€™s especially useful for object-based discriminated unions like API responses or domain models.