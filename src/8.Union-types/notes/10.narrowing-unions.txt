â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ“˜ LESSON: Narrowing Down the Type of a Union
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Welcome back, students.

In this lesson, weâ€™ll talk about **narrowing down** the type of a union in TypeScript.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ Example Setup
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Letâ€™s start with a simple type:

```ts
type DataTypes = string | number | boolean;

function parseData(data: DataTypes) {
  // logic goes here
}
Here, data can be either a string, number, or boolean.

However, sometimes inside our function we need to perform logic that only applies to one of those types â€” for example, we might want to call .length, which only exists on strings.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ Using typeof for Narrowing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

We can use the typeof keyword to narrow the type of a variable inside a scope:

ts
Copy code
function parseData(data: DataTypes) {
  if (typeof data === "string") {
    console.log(data.length); // âœ… data is now a string
  } else if (typeof data === "number") {
    console.log(Math.sqrt(data)); // âœ… data is now a number
  } else {
    console.log(!data); // âœ… data is now a boolean
  }
}
ðŸ’¡ Inside each branch, TypeScript automatically infers the correct type:

In the first if, data is a string.

In the second, itâ€™s a number.

In the final else, itâ€™s a boolean.

Outside these scopes, the type goes back to string | number | boolean.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ Checking with Hover (in VS Code)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

If you hover over data inside the if (typeof data === "string") block, youâ€™ll see that itâ€™s inferred as string.

If you hover in the next block, youâ€™ll see itâ€™s a number.

Outside all conditions, itâ€™s inferred again as string | number | boolean.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ Extracting Type Checks into Helper Functions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

To make your code cleaner, you can extract type checks into small helper functions:

ts
Copy code
const isString = (value: unknown): value is string => typeof value === "string";

function parseData(data: DataTypes) {
  if (isString(data)) {
    console.log(data.length); // clearly a string
  }
}
This makes your code easier to read, especially when you have nested if statements.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Use typeof to narrow primitive unions like string | number | boolean.

Each scope inside an if or else if narrows the type.

You can use custom type guard functions like isString for better