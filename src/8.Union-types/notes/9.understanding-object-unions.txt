ğŸŸ£ Extracting All Keys from a Union of Objects

When working with objects in TypeScript, you might sometimes want to get all the keys that appear in any of the objects in a union.

However, thereâ€™s a small gotcha:
using the keyof operator directly on a union of objects will only give you the keys common to every member â€” not all unique keys.

Letâ€™s see this in action ğŸ‘‡

ğŸ§© Example: Two Object Types
type ObjectA = {
  x: string;
  y: number;
};

type ObjectB = {
  x: string;
  z: boolean;
};


Here:

Both objects share the key x.

ObjectA has a y.

ObjectB has a z.

âš ï¸ Using keyof on a Union
type CommonKeys = keyof (ObjectA | ObjectB);


If we hover over CommonKeys, TypeScript gives us:

// Result: "x"


ğŸ˜® Only x!
Thatâ€™s because keyof on a union type returns only the keys that exist in every member of the union.

ğŸ¯ Goal

We want all keys that appear in any object â€”
so the result should be:

// Expected: "x" | "y" | "z"

ğŸ’¡ Solution: Distributive Conditional Type

To make TypeScript process each union member separately,
we can use a conditional type that forces distribution.

Hereâ€™s how ğŸ‘‡

type AllKeys<T> = T extends unknown ? keyof T : never;

âœ… How This Works

The condition T extends unknown always passes.

Because itâ€™s a conditional type, TypeScript will:

Take each member of the union one by one (ObjectA, then ObjectB).

Apply keyof to each.

Merge the results back into a union.

ğŸ§  Testing the Solution
type Result = AllKeys<ObjectA | ObjectB>;


If we hover over Result, we get:

// Result: "x" | "y" | "z"


ğŸ‰ Perfect! Now we have all keys from both objects.

ğŸ” Behind the Scenes

Hereâ€™s what TypeScript does internally:

(ObjectA extends unknown ? keyof ObjectA : never) |
(ObjectB extends unknown ? keyof ObjectB : never)


Which becomes:

("x" | "y") | ("x" | "z")
// Simplifies to:
"x" | "y" | "z"

âš™ï¸ Important Detail: Two Uses of T

Notice that we used T in two places:

type AllKeys<T> = T extends unknown ? keyof T : never;


Are they the same?
Not exactly.

Position	Meaning
Outer T	Represents the entire union (`ObjectA
Inner T (inside conditional)	Represents each individual member (ObjectA then ObjectB).

So the outer T is the whole set,
while the inner T gets distributed one by one â€”
and thatâ€™s how we get all keys.

ğŸ§¾ Summary

âœ… keyof on a union gives only common keys.
âœ… To get all keys, use a distributive conditional like:

type AllKeys<T> = T extends unknown ? keyof T : never;


âœ… TypeScript then applies keyof to each union member separately
and merges the results into one combined union.

âœ¨ In Short:

If you ever need all keys from a union of objects â€”
force distribution with a conditional type.
Itâ€™s the magic trick that unlocks "x" | "y" | "z".