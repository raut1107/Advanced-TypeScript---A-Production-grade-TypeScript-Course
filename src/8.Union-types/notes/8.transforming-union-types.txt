ğŸŸ£ Enforcing Distributive Behavior in Conditional Types

Welcome back, students! ğŸ‘‹

Weâ€™ve already learned that when we combine conditional types with union types,
TypeScript applies the condition to each member of the union separately â€”
and then merges all the transformed results back into a single union.

In this lesson, weâ€™ll explore how to enforce that distributive behavior when TypeScript doesnâ€™t automatically apply it.

ğŸ§© Example: String Variants Type

Letâ€™s start with a simple type definition ğŸ‘‡

type StringVariants<S extends string> = [Lowercase<S>, Uppercase<S>];


This type receives a string S and returns a tuple containing:

The lowercase version of the string.

The uppercase version of the string.

ğŸ§  Testing It
type SV1 = StringVariants<"Hi">;
// Result: ["hi", "HI"]


âœ… Works perfectly â€” we get a tuple of lowercase and uppercase versions.

âš ï¸ Now Letâ€™s Try a Union

What if we pass a union of strings instead?

type SV2 = StringVariants<"Hi" | "Bye">;


You might expect this result:

// Expected:
// ["hi", "HI"] | ["bye", "BYE"]


But what you actually get is:

// Actual:
// [ "hi" | "bye", "HI" | "BYE" ]


Uh oh ğŸ˜… â€” the results are mixed up.
Instead of distributing over each member of the union,
TypeScript applied the transformation to the union as a whole.

ğŸ” Why Distribution Didnâ€™t Happen

By default, distributive behavior only happens in conditional types â€”
not in plain type declarations like ours.

So, when thereâ€™s no conditional check (extends ... ? ... : ...),
TypeScript wonâ€™t distribute the transformation across union members.

ğŸ’¡ The Fix â€” Introduce a Conditional Layer

We can force distribution by adding a trivial condition â€”
something thatâ€™s always true, such as S extends any ? ... : never.

Hereâ€™s how it looks ğŸ‘‡

type StringVariants<S extends string> =
  S extends any
    ? [Lowercase<S>, Uppercase<S>]
    : never;


Now, this condition ensures that:

Each member of the union ("Hi" and "Bye")
is processed separately.

The results are merged back into a distributed union.

âœ… Testing Again
type SV3 = StringVariants<"Hi" | "Bye">;
// Result:
// ["hi", "HI"] | ["bye", "BYE"]


Perfect! ğŸ‰
Now weâ€™re getting exactly what we wanted â€” the transformation applies to each member individually.

ğŸ§  Why This Works

Adding S extends any introduces a distributive conditional:
TypeScript internally expands the union like this:

("Hi" extends any ? ["hi", "HI"] : never) |
("Bye" extends any ? ["bye", "BYE"] : never)


And then merges them together into one union.

ğŸ”¸ Key Takeaways

âœ… Distribution of union members happens only in conditional types.
âœ… To enforce it, wrap your type logic inside a condition like S extends any ? ... : never.
âœ… This ensures each member of a union is processed independently and merged cleanly.

âœ… In short:

If you ever need your generic transformation to apply individually to each union member,
just add an extends any check â€” itâ€™s your key to distributive magic in TypeScript.