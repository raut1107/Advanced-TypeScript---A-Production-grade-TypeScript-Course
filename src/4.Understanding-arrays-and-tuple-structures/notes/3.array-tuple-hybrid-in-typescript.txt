ğŸŒŸ Variadic Tuples in TypeScript

With the introduction of variadic tuples in TypeScript, you can now combine tuples and arrays in powerful ways.
This allows you to define array types that follow specific structural patterns, such as always starting or ending with particular values â€” while still permitting any number of elements in between.

ğŸ”¹ What Are Variadic Tuples?

Variadic tuples extend the concept of tuples by allowing a flexible number of elements, while still maintaining type safety.
They let you define tuple patterns that can expand using the spread operator (...).

ğŸ”¹ Example 1 â€” Arrays That Start with a Specific Value

Imagine you need an array of numbers that always starts with the value 5, followed by any number of additional numbers.

type StartsWithFive = [5, ...number[]];

const valid: StartsWithFive = [5, 10, 20, 30]; // âœ… valid
const invalid: StartsWithFive = [10, 5, 20];   // âŒ error â€” must start with 5


âœ… This type enforces that the first element must be 5, and the rest can be any number.

ğŸ”¹ Example 2 â€” Arrays That End with a Specific Value

Now imagine you want an array of strings that must always end with a period (".").

type EndsWithPeriod = [...string[], "."];

const validSentence: EndsWithPeriod = ["Hello", "world", "."];
const invalidSentence: EndsWithPeriod = ["Hello", "world"]; // âŒ missing "."


âœ… This ensures that the final element in the array is always ".".

ğŸ”¹ Example 3 â€” Arrays That Are Never Empty

You can also use variadic tuples to ensure that an array contains at least one element â€” useful when you donâ€™t want empty arrays.

type NonEmptyBooleans = [boolean, ...boolean[]];

const ok: NonEmptyBooleans = [true];
const alsoOk: NonEmptyBooleans = [false, true, false];
const notOk: NonEmptyBooleans = []; // âŒ error â€” must have at least one element


âœ… The first element is mandatory, guaranteeing the array is never empty.

ğŸ”¹ Example 4 â€” Arrays That Start and End with Specific Values

Suppose you want an array of numbers that must start and end with -1, but can contain any number of other numbers in between.

type StartAndEndWithNegativeOne = [-1, ...number[], -1];

const valid: StartAndEndWithNegativeOne = [-1, 2, 3, 4, -1];
const invalid: StartAndEndWithNegativeOne = [2, -1, 4]; // âŒ must start with -1


âœ… This pattern enforces both the start and end constraints.

ğŸ”¹ Example 5 â€” Pattern-Based Arrays (Custom Structure)

Imagine an identification code that must begin with either "A" or "B", followed by any number of digits.

type IDCode = ["A" | "B", ...number[]];

const id1: IDCode = ["A", 1, 2, 3, 4];
const id2: IDCode = ["B", 7, 8, 9];
const invalidId: IDCode = ["C", 5, 6]; // âŒ must start with A or B


âœ… The pattern [ "A" | "B", ...number[] ] ensures that the first element is one of the allowed prefixes, followed by digits only.

ğŸ§  Key Takeaways
Concept	Description	Example
Variadic Tuples	Tuples that can expand with the spread operator	[5, ...number[]]
Fixed Start	Enforce a specific first element	[5, ...number[]]
Fixed End	Enforce a specific last element	[...string[], "."]
Non-Empty Array	Require at least one element	[boolean, ...boolean[]]
Pattern Matching	Define arrays with structural constraints	`["A"
ğŸ¯ Summary

Variadic tuples combine the precision of tuples with the flexibility of arrays.

You can enforce start, end, or pattern rules on arrays while still allowing flexible lengths.

Perfect for modeling structured, rule-based sequences like identifiers, tokens, or formatted data.