ğŸŒŸ Readonly Arrays in TypeScript

In TypeScript, arrays are mutable by default, meaning they can be modified â€” you can push, pop, or directly assign elements.
However, sometimes you want to prevent accidental modification of an array, especially when a function should only read from it.

Thatâ€™s where readonly arrays come in.
They allow you to define arrays that cannot be changed â€” no pushing, popping, or reassigning values.

ğŸ”¹ The Problem â€” Unintended Array Mutation

Letâ€™s start with a simple function that logs messages:

function logMessages(messages: string[]) {
  for (const message of messages) {
    console.log(message);
  }

  // âŒ Unsafe modification
  messages.push("New message");
  messages[0] = "Updated!";
}


This function accepts an array of strings, but notice that inside it, weâ€™re modifying the array by:

Adding a new message using .push()

Updating an element using index access

This could lead to unexpected side effects â€” since the original array passed from outside would now be altered.

ğŸ”¹ The Solution â€” Using readonly Arrays

To prevent mutation, we can tell TypeScript that the array parameter should be readonly:

function logMessages(messages: readonly string[]) {
  for (const message of messages) {
    console.log(message);
  }

  // âŒ Type error: Property 'push' does not exist on type 'readonly string[]'
  messages.push("New message");

  // âŒ Type error: Index signature in type 'readonly string[]' only permits reading
  messages[0] = "Updated!";
}


âœ… Explanation:

Adding readonly before the type name (string[]) makes it immutable.

Any attempt to push, pop, or reassign elements will cause a TypeScript compile-time error.

ğŸ”¹ Alternative Syntax â€” Using the ReadonlyArray Generic Type

TypeScript also provides a generic utility type for creating readonly arrays:

function logMessages(messages: ReadonlyArray<string>) {
  for (const message of messages) {
    console.log(message);
  }
}


âœ… This syntax is equivalent to using readonly string[].
Both approaches ensure the same immutability â€” the difference is just stylistic.

ğŸ”¹ Example â€” Passing a Readonly Array

When calling the function, you can safely pass any array:

const logs = ["Info", "Warning", "Error"];
logMessages(logs);


Even though logs is a normal mutable array, inside the logMessages function, TypeScript treats it as readonly, ensuring that it cannot be changed accidentally.

ğŸ§  Key Takeaways
Concept	Description	Example
Readonly Modifier	Prevents mutation of arrays	readonly string[]
Generic Equivalent	Alternative style for readonly arrays	ReadonlyArray<string>
Mutation Prevention	Blocks .push(), .pop(), and direct assignments	messages.push("x") âŒ
Safe Functions	Ensures a function only reads, never writes	function logMessages(messages: readonly string[])
ğŸ¯ Summary

Use readonly arrays when you want to protect data from accidental modification.

Both readonly string[] and ReadonlyArray<string> are functionally identical.

This small addition can make your code safer, more predictable, and easier to reason about, especially in large projects.
